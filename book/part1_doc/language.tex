\chapter{PML language and syntax}

\section{Sorts}\label{lang-sort}

PML language uses \emph{sorts} to classify all the expressions of the
languages (except sorts) like types, values, ordinals, \dots


\def\w{9.2cm}
\begin{longtable}{rll}
\multicolumn{2}{l}{\noindent \emph{sort} $::=$}\\
  & $\iota$ \Mid {\tt <iota>} \Mid {\tt <value>}
  & \parbox[t]{\w}{denote the sort for values i.e. results of computation.} \\

  \Mid
  & $\tau$ \Mid {\tt <tau>} \Mid {\tt <term>}
  & \parbox[t]{\w}{denote the sort for terms i.e. program that evaluates to value.} \\

  \Mid
  & $\sigma$ \Mid {\tt <sigma>} \Mid {\tt <stack>}
  & \parbox[t]{\w}{denote the sort of stacks which is used when programming with classical
  logic.}\\

  \Mid
  & $o$ \Mid {\tt <omicron>} \Mid {\tt <prop>}
  & \parbox[t]{\w}{denote the sort of types for terms or propositions (following the
  Curry-Howard correspondance PML identifies types and proposition).
  The letter $o$ is the unicode character omicron, not a lower case latin letter.} \\

  \Mid
  & $\kappa$ \Mid {\tt <kappa>} \Mid {\tt <ordinal>}
  & \parbox[t]{\w}{denote the sort of ordinals used to index inductive and co-inductive
  types.} \\

  \Mid
  & \emph{sort} $\rightarrow$ \emph{sort}
  & \parbox[t]{\w}{the sort for higher-order function like types with parameters. These
  higher-order functions should not be confused with functions as programs
  which are of sort $\iota$ or $\tau$. This symbol is right associative,
  $s_1 \rightarrow  s_2 \rightarrow s_3$ means
  $s_1 \rightarrow (s_2 \rightarrow s_3)$.} \\

  \Mid
  & {\tt (} \emph{sort} {\tt )}
  & \parbox[t]{\w}{parenthesis can be used for grouping.} \\
\end{longtable}

The sort $\iota$ is a subsort of $\tau$. This means that any value can also
be considered as a term.

\section{Expressions}\label{lang-expr}

In this section we describe the BNF of PML's expressions written \emph{expr}. We will denote
\begin{itemize}
\item \emph{value} the expression of sort $\iota$,
\item \emph{term} the expression of sort $\tau$,
\item \emph{stack} the expression of sort $\sigma$,
\item \emph{prop} the expression of sort $o$,
\item \emph{ordi} the expression of sort $\kappa$.
\end{itemize}

\subsection{Atoms}

We now give a few atomic tokens used in the grammar below.

\begin{longtable}{rll}
\emph{uid} &$::=$& {\tt [A-Z\_][a-zA-Z0-9\_']*} \Mid {\tt true}
\Mid {\tt false}\\
\emph{lid} &$::=$& {\tt [a-z\_][a-zA-Z0-9\_']*} \\
\emph{id}  &$::=$& \emph{lid} \Mid \emph{lid} : \emph{prop} \\
\emph{lbl} &$::=$& {\tt [a-zA-Z0-9\_']+} \\
\emph{int} &$::=$& {\tt [-]?[0-9]+} \\
\emph{infix} &$::=$& \hbox{ must be declared see \ref{lang-top}}.\\
\emph{string} &$::=$& \dupml{"}.*\dupml{"}
  \hbox{ with the usual quoting like \dupml{"\n"}.}\\
\end{longtable}

\subsection{Values}

The priority level for terms and values are, from the lowest to the highest priority:
\begin{itemize}
\item F: full
\item S: sequence
\item R: prefix
\item I: infix
\item P: application
\item A: atom
\end{itemize}

When the priority is not F, we subscrit the non terminal
$\emph{value}$ and $\emph{term}$ with the priority.
We write the priority of each rule at the end of the rule.
The priority between infix symbols and their associativity are given
at the declaration see \ref{lang-top}.

\def\w{10cm}
\begin{longtable}{rlcl}
  \multicolumn{2}{l}{\emph{value} $::=$}\\
  & $\dupml{λ}\emph{id} \dots \emph{id}\dupml{.} \emph{term}_I$ & R & \\
  \Mid & $\dupml{fun} \; \emph{id} \dots \emph{id} \; \{ \emph{term} \}$ & A
    & \parbox[t]{\w}{denotes function with one or more arguments.} \\

  \Mid & \dupml{[]} & A &\\
  \Mid & $\emph{value}_I \dupml{::} \emph{value}_I$ & I &\\
  \Mid & $\emph{uid} \mid \emph{uid} \dupml{[} \emph{value} \dupml{]}$ & A
  & \parbox[t]{\w}{constructor applied to no argument or one argument. In
    fact, no argument means applied to unit, i.e. \dupml{{}}. \dupml{[]} is a short
    hand for $\dupml{Nil}$ and \dupml{t :: u} means \dupml{Cons[{hd = t; tl = u}]}.} \\

  \Mid & $\{ \emph{lbl} \dupml{=} \emph{value} \dupml{;} \dots \}$ & A
  & \parbox[t]{\w}{construction of a record. As in OCaml, a label alone means
    the label used both as label and value. For
    instance, \dupml{{ hd; tl }} means  \dupml{{ hd = hd; tl = tl }}.} \\

  \Mid & $\dupml{(} \emph{value}\dupml{,} \dots\dupml{)}$ & A
  & \parbox[t]{\w}{tuple construction. As in standard ML this is equivalent
    to a record with numerical labels $1,2,\dots$.} \\

  \Mid & \dupml{(} \emph{value} \dupml{:} \emph{prop} \dupml{)} & A
  & \parbox[t]{\w}{type annotation} \\
\end{longtable}


\subsection{Terms}

\def\w{9.2cm}
\begin{longtable}{rlcl}
    \multicolumn{2}{l}{\emph{term} $::=$}\\
  & $\emph{term}_P \; \emph{term}_A$ & P
  & \parbox[t]{\w}{function application. It is left associative: \dupml{t1 t2
    t3} means \dupml{(t1 t2) t3}.}\\

  \Mid & $\emph{term}_I \dupml{::} \emph{term}_I$ & I \\ \Mid & $\emph{uid}
  \dupml{[}\emph{term}\dupml{]}$ & A & \parbox[t]{\w}{syntactic sugar :
    \dupml{C[t]} means \dupml{(λx.C[x])t} when \dupml{t} is not a value. The
    same for the syntactic sugar for {\tt Cons} if one or both arguments are
    not valuesaf, one or two redexes are inserted.} \\

  \Mid & $\{ \emph{lbl} \dupml{=} \emph{term} ; \dots \}$ & A
  & \parbox[t]{\w}{As above, a redex is added for each field which is not a
    value in a record construction.} \\

  \Mid & $\dupml{(}\emph{term}, \dots\dupml{)}$ & A
    & \parbox[t]{\w}{As above, a redex is added for each field which is not a
    value in a tuple construction.} \\

  \Mid & \emph{int} & A & \parbox[t]{\w}{a syntactic sugar is created to
    represent the given integer using function {\tt zero},  \dupml{succ}, {\tt
      dble}, and  \dupml{opp}. For instance, \dupml{5} means \dupml{succ (dble
      (dble (succ zero)))}.} \\

  \Mid & $\!\!\!\begin{array}[t]{l}\dupml{if} \; \emph{term} \; \{ \emph{term} \}\\ \dupml{else}
  \; \{ \emph{term} \}\end{array}$ & A \\
  \Mid & $\dupml{case} \; \emph {term} \; \{ \emph{pat}  \dupml{→}\emph{term} \dots \}$ & A &
    \parbox[t]{\w}{case analysis over sum types. See below for the definition
      of the BNF \emph{pat}. The syntax $\dupml{if b {t} else {u}}$ means
      \dupml{case b { true → t false → u}}.} \\

  \Mid & U+2702 & A & \parbox[t]{\w}{scissors denote inaccessible part of
    a term, in general an impossible case}\\

  \Mid & $\dupml{save} \; \emph{lid} \{ \emph{term} \}$ & A & \parbox[t]{\w}{saves the
    current evaluation context (i.e. the stack) for future use with {\tt
      \dupml{restore}}.} \\

  \Mid & $\dupml{restore} \; \emph{lid} \; \emph{term}_A $ & I & \parbox[t]{\w}{restores
    a previously stored evaluation context and evaluate the given term in
    it. This statement corresponds to the $c$ effect.}\\

  \Mid & $\dupml{delim} \; \{ \emph{term} \} $ & A & \parbox[t]{\w}{If the given term
    does not use the $c$ effect in its type or the type of its free variables,
    we know that the \dupml{restore} statement can not escape the term and
    the $c$ effect can be ignored for that term.} \\

  \Mid & $\dupml{print} \; \emph{string}$ & A & \parbox[t]{\w}{Print the given
    string on the standard output. This expression is annotated with the $p$
    effect.}\\

  \Mid & $\dupml{fix} \; \emph{id} \{ \emph{term} \}$ & A & \parbox[t]{\w}{
      The term $\dupml{fix x {t}}$ is a fixpoint, meaning that
      it is equivalent to $\dupml{t}[\dupml{x}:=\dupml{fix x { t }}]$. PML must be able
      to prove the termination of this fixpoint unless the current context is
      annotated with the $l$ effect.} \\

  \Mid & $\emph{term}_R \dupml{;} \emph{term}_S$ & S & \parbox[t]{\w}{
    sequence of terms are redexes. The term \dupml{t; u} means \dupml{(fun x
      {u}) t}.}\\

  \Mid & $\dupml{let}\; \emph{id} \dupml{=} \emph{term}_R\dupml{;} \emph{term}_S$ & S \\
  \Mid & $\dupml{let rec}\; \emph{id} \dupml{=} \emph{term}_R\dupml{;} \emph{term}_S$ & S &
    \parbox[t]{\w}{The first form is a syntactic sugar for a redex.
      \dupml{let x : a = u; t} means \dupml{(fun x : a { t }) u}.
      The second form uses a fixpoint in the definition:
      \dupml{let rec x : a = u; t} means \dupml{(fun x : a { t }) (fix x : a {u})}.} \\

  \Mid & \dupml{(} \emph{term} \dupml{:} \emph{prop} \dupml{)} & A
  & \parbox[t]{\w}{type annotation} \\

  \Mid & $\dupml{{- ⋯ -}}$ & A & \parbox[t]{\w}{denotes a hole in a term, a term
      yet to be written. It must not contain a newline, but could use any
      other character.}\\

  \Mid & $\dupml{set} \; \emph{option} \dupml{;} \emph{term}_S$ & S &
      \parbox[t]{\w}{allow to set some option to tune pml
        behavior for the typechecking of the given term. See \ref{lang-top}
        for more detail.}\\
\end{longtable}

\subsection{Stacks}

There is no specific syntax for stacks except for identifier introduced by the
\dupml{save} keyword.

\def\w{9.2cm}
\begin{longtable}{rll}
\end{longtable}

\subsection{Ordinals}

Ordinals are used only to index least and greatest fixpoint used to build
inductive and co-inductive type. They are used to prove termination of
programs by \emph{ordinal induction} but also to prove subtyping.

\def\w{12cm}
\begin{longtable}{rll}
  \multicolumn{2}{l}{\emph{ordi} $::=$}\\
  & $\infty$ & \parbox[t]{\w}{denotes an ordinal large enough to imply the
    convergence of all PML $mu$ and $nu$ fixpoint. $\mu x, p$ means $\mu\_\infty x, t$. } \\
  \Mid & $\emph{ordi} +_o \emph{int}$ & \parbox[t]{\w}{denotes the addition
    of a positive natural to an ordinal.} \\
\end{longtable}

\subsection{Propositions}

Prorities for parsing proposition are the following from lowest to highest:
\begin{itemize}
  \item $F$ : full
  \item $P$ : product
  \item $R$ : restriction
  \item $M$ : member
  \item $A$ : atom
\end{itemize}

\def\w{9.5cm}
\begin{longtable}{rlcl}
  \multicolumn{2}{l}{\emph{prop} $::=$}\\
       & $\emph{prop}_P \dupml{⇒} \emph{prop}$ & F & \\
  \Mid & $\emph{prop}_P \dupml{→} \emph{prop}$ & F & \\
  \Mid & $\emph{prop}_P \dupml{↝} \emph{prop}$ & F &\\
  \Mid & $\emph{prop}_P \dupml{→_}(\emph{effects}) \emph{prop}$ & F &
  \parbox[t]{\w}{propositional
  implication and function type. The implication is indexed by the possible
  effects of the function. Currently $l$ if the function may loop, $p$
    if the function performs some printing on the standard output and $c$
    if the function may restore a previously saved stack. The symbol
  \dupml{⇒} is a short cut for pure function type
  i.e. \dupml{→_()}. The symbol \dupml{→} and \dupml{↝} mean respectively
  \dupml{→_(cp)} and \dupml{→_(cpl)}. }\\

  \Mid & $\emph{prop}_R \dupml{×} \emph{prop}_R \dupml{×} \dots$ & P & product type (i.e. type
  of tuple.). \\

  \Mid & $\{ \emph{lid} : \emph{prop} \dupml{;} \dots \}$ & A &\\
  \Mid & $\{ \emph{lid} : \emph{prop} \dupml{;} \dots \dupml{;} \dupml{...} \}$ & A &
  \parbox[t]{\w}{record type, indicating the type of each field. If there is
    three dots before the closing brace, the record type is open, more fields
    may be present in an element of this type. In fact, the strict version is
    a syntactic sugar.  \dupml{{ l : A; l' : B}} means \dupml{∃x y:ι, {
        l = x; l' = y } ∈ { l : A; l' : B ; ⋯ }}.  The final dots may
    be one unicode character or three ascii dots.} \\

  \Mid & $\emptyset$ & A &\\
  \Mid & \dupml{[.]} & A &\\
  \Mid & $\dupml{[} \emph{uid} \; \dupml{of} \; \emph{prop} ; \dots \dupml{]}$ & A &
  \parbox[t]{\w}{sum type indicating the type of the argument of each
    constructor. The annotation $\dupml{of}\; \emph{prop}$ may be ommited if the type is
    unit, i.e. \dupml{{}}. $\emptyset$ and \dupml{[.]} both denote the empty sum
    type. \dupml{[]} is the empty list and not a sum type.} \\

  \Mid & $\emph{term}_I \dupml{∈} \emph{prop}_M$ & M &
  \parbox[t]{\w}{denotes the singleton type containing only the given term of
    the given type.} \\

  \Mid & $\emph{prop}_R \dupml{|} \emph{term}_I \dupml{≡} \emph{term}_I$ & R &\\
  \Mid & $\emph{prop}_R \dupml{|} \emph{term} \dupml{↓}$ & R &\\
  \Mid & $\emph{term}_I \dupml{≡} \emph{term}_I$ & R &\\
  \Mid & $\emph{term}_I$ & A &
  \parbox[t]{\w}{corresponds to the restiction type. It is the empty type if
    the condition is false, otherwise it is the given type. The condition
    $t_1 \equiv t_2$ is true when $t_1$ and $t_2$ are equivalent (PML
    equivalence is more of less observational equivalence). $t_1\downarrow$
    is true if $t_1$ evaluates to a value. The two last forms are syntactic
    sugar: \dupml{t ≡ u} means \dupml{{} | t ≡ u} and \dupml{t} used as a
    proposition means \dupml{{} | t ≡ true}. The last form allows to use any
    term of boolean type as a proposition.} \\

  \Mid & $\emph{term}_I \dupml{≡} \emph{term}_I \dupml{↪} \emph{prop}_M$ & R & \\
  \Mid & $\emph{term}_I \dupml{↓}  ↪ \emph{prop}_M$ & R &
  \parbox[t]{\w}{denotes propositional implication. The type is the top type
    containing all terms if the condition is false. It is the given type
    otherwise. This type differs from restriction only when the condition is false.} \\

  \Mid & $\dupml{∀} \emph{id} \dots\dupml{,} \emph{prop}$ & F & \\
  \Mid & $\dupml{∀} \emph{id} \dots\dupml{:} \emph{sort}\dupml{,} \emph{prop}$ & F &\\
  \Mid & $\dupml{∀} \emph{id} \dots\dupml{∈} \emph{prop}\dupml{,} \emph{prop}$ & F &
  \parbox[t]{\w}{denotes universal quantification. In the first form, the
    sort of the variables is infered by PML while in the second form it is
    explicitely written. The last form is a short cut for dependant type.
    \dupml{∀ x y ∈  A,B} means \dupml{∀ x y : ι, x ∈ A ⇒ y ∈ A ⇒  B}.} \\

  \Mid & $\dupml{∃} \emph{id} \dots\dupml{,} \emph{prop}$ & F &\\
  \Mid & $\dupml{∃} \emph{id} \dots\dupml{:} \emph{sort}\dupml{,} \emph{prop}$ & F &\\
  \Mid & $\dupml{∃} \emph{id} \dots\dupml{∈} \emph{prop}\dupml{,} \emph{prop}$ & F &\\
  \Mid & $\{ \emph{id} \dupml{∈} \emph{prop}\}$ & F &
  \parbox[t]{\w}{denotes existential quantification. In the first form, the
    sort of the variables is infered by PML while in the second form it is
    explicitely written. The last form is a short cut for dependant product.
    \dupml{∃ x y ∈ A,B} means \dupml{∃ x y : ι, x
    ∈ A × y ∈ A × B}. The last form is also a
    short cut: \dupml{{x ∈  A}} means \dupml{∃ x, x ∈ A}.} \\

  \Mid & $\dupml{μ} \emph{id}\dupml{,} \emph{expr}$ & F &\\
  \Mid & $\dupml{μ_}\emph{ordi} \; \emph{id}\dupml{,} \emph{expr}$ & F &
  \parbox[t]{\w}{Least fixpoint of proposition or parametric
    proposition. This means that \dupml{μx, a} may be of sort $s_1 \rightarrow
    \dots s_n \rightarrow o$ when both \dupml{x} and \dupml{a} have this sort. The
    form with an ordinal denotes a partial construction of the fixpoint and
    is used to prove termination of programs.} \\

  \Mid & $\dupml{ν} \emph{id}\dupml{,} \emph{expr}$ & F &\\
  \Mid & $\dupml{ν_}\emph{ordi} \; \emph{id}\dupml{,} \emph{expr}$ & F &
  \parbox[t]{\w}{Greatest fixpoint of proposition or parametric
    proposition. This means that \dupml{νx, a} may be of sort $s_1 \rightarrow
    \dots s_n \rightarrow o$ when both \dupml{x} and \dupml{a} have this sort. The
    form with an ordinal denotes a partial construction of the fixpoint and
    is used to prove productivity of programs.} \\
\end{longtable}

\subsection{General expressions}


\def\w{11cm}
\begin{longtable}{rll}
  \multicolumn{2}{l}{\emph{expr} $::=$}\\
  & $ \emph{lid} $ & variable. \\

  \Mid & $\dupml{(} \emph{lid} \dupml{:} \emph{sort} \dupml{↦} \emph{expr} \dupml{)}$ &
  \parbox[t]{\w}{corresponds to
  higher-order abstraction. If \dupml{e} is an expression of sort \dupml{s} using a
  variable \dupml{x} of sort \dupml{t} then \dupml{(x : t ↦ e)} is of sort
  \dupml{t → s}.} \\

  \Mid & $\emph{expr}\dupml{⟨}\emph{expr}, \dots\dupml{⟩}$ &
  \parbox[t]{\w}{denotes higher-order application. \dupml{e1⟨e2,e3⟩} is a short cut for \dupml{e1⟨e2⟩⟨e3⟩}. \dupml{e1⟨e2⟩} is of sort \dupml{s} if \dupml{e1} is of sort
    \dupml{t → s} and \dupml{e2} is of sort \dupml{s1}.}\\

  \Mid & \dupml{(} \emph{expr} \dupml{)} & parenthesis for grouping.\\
\end{longtable}

\subsection{proofs}

PML does not have a specific language for proofs. However, we provide a few
syntactic sugar to make proofs more readable for non specialist.

We first give a BNF for a few equivalent keywords. Depending on the proofs,
some keyword may give a more natural proofs than other.

\begin{longtable}{lllclcl}
\emph{show} &::= & \dupml{show} &\Mid& \dupml{deduce} &\Mid& \dupml{prove}\\
\emph{know} &::= & \dupml{assume} &\Mid& \dupml{know}\\
\emph{from} &::= & \dupml{from} &\Mid& \dupml{showing} \\
\emph{by} &::= & \dupml{because} &\Mid& \dupml{using} &\Mid& \dupml{by} \\
\end{longtable}

First, we have the \dupml{qed} keyword and
two syntactic sugar to define function application that we use
when the type of the variable are hypothesis of a theorem:

\def\w{9.5cm}
\begin{longtable}{rlcl}
  \multicolumn{2}{l}{\emph{value} $::= ...$} & \\
  \Mid & $\dupml{qed}$ & A & a synonymous for the empty record $\{\}$.\\
  \Mid & $\dupml{take} \; \emph{id} \dots \emph{id }  \{ \emph{term} \}$ & A &\\
  \Mid & $\dupml{suppose}\; \emph{prop}, \dots ; \emph{term}_S$ & S &
   \parbox[t]{\w}{the syntax with the \dupml{take} keyword is fully equivalent
     the same with \dupml{fun} and is used to prove universal quantifications.
     We use \dupml{suppose} when we do not need
   a name for the variables, typically for types which are equivalence. For
   instance
   \dupml{suppose a ≡ b; t} means \dupml{fun _ : a ≡ b { t }}.} \\
\end{longtable}

Then, we have a few extension for expressions

\def\w{9.2cm}
\begin{longtable}{rlll}
  \multicolumn{2}{l}{\emph{expr} $::= ...$} \\
  \Mid & $\dupml{use} \; \emph{term}_R$ & R & \parbox[t]{\w}{the statement $\dupml{use}\;
    t$ is equivalent to $t$ but may be more natural when $t$ is the
    invocation of some lemma or theorem.}\\
  \Mid & $\emph{show} \; \emph{prop}_R $ & R \\
  \Mid & $\emph{show} \; \emph{prop} \;\emph{by} \; \emph{term}_R $ & R\\
  \Mid & $\emph{show} \; \emph{prop} \;\emph{by} \; \{\emph{term}\} $ & R \\
  \Mid & $\emph{show} \; \emph{term}_R
         \begin{array}[t]{l}
           \equiv \emph{term}_R \; \emph{by} \; \emph{term}_R \\
           \equiv \emph{term}_R \; \emph{by} \; \emph{term}_R \\
           \dots
         \end{array}$ & S &
         \parbox[t]{\w}{The first form \dupml{show p} is equivalent to
           \dupml{(qed : p)}. The second \dupml{show p by u} means \dupml{(u : p)}. The last form is equivalence to a sequence
           of \dupml{show}, the justification of each line being optional. For
           instance $\begin{array}[t]{ll}\dupml{show a} &\dupml{≡ b
             using l} \\ &\dupml{≡ c} \end{array}$ means $(l :
           a \equiv b); (\dupml{qed} : b \equiv c)$.}\\

  \Mid & $\emph{from} \; \emph{prop}\dupml{;} \emph{term}_S$ & S \\
  \Mid & $\emph{from} \; \emph{prop} \; \emph{by} \; \emph{term}_R \dupml{;} \emph{term}_S$ & S & \parbox[t]{\w}{is
    used for backward reasonning to mean that the current goal is implied by
    the given proposition. This can not be the last statement of a proof
    hence the term at the end. \dupml{from a by u; t} means
     \dupml{let _ : a = u; p}.}\\

  \Mid & $\emph{know} \; \emph{term}_R; \; \emph{term}_S$ &S& \\
  \Mid & $\emph{know} \; \emph{term}_R \; \emph{by} \; \emph{term}_R; \;
  \emph{term}_S$ & S  &
    \parbox[t]{\w}{\dupml{know t; p} perfoms
    a case analysis on \dupml{t} to prove that \dupml{t} is equal to \dupml{true}. It is
    expended to \dupml{case t { false → qed   true → p  }}. \dupml{know t by
    q; p} means \dupml{case t { false → q     true → p  }}. Again, this can not be the last
    statement of a proof hence the final term.} \\

\end{longtable}

\section{Top level statements}\label{lang-top}

PML support some options to tune its behavior using the \dupml{set} statement:
  More details are given on the command line options in section \ref{lang-cmd}.

$\begin{array}{lrl}
  \emph{option} &::=& \dupml{log} \; \emph{string} \\
  &\mid& \dupml{auto} \; \emph{int} \; \emph{int}\\
  &\mid& \dupml{keep_intermediate}
\end{array}
$.


\section{Command line}

The command take a list of option described below and a list of pml file to
compile.  Here is the result of \verb!pml --help!:

\begin{verbatim}
Usage: pml [args] [f1.pml] ... [fn.pml]
  --log-file file      Write logs to the provided file.
  --log str            Enable the provided logs. Available options:
                    - a: automatic proving informations
                    - c: comparing informations
                    - e: equivalence decision procedure
                    - f: details of equivalence decision
                    - o: ordinal comparison
                    - p: syntax analysis
                    - s: subtyping informations
                    - t: typing informations
                    - u: unification informations
                    - y: size change principle
                    - z: effect computation.
  --full-compare       Show all the steps when comparing expressions.
  --always-colors      Always use colors.
  --timed              Display a timing report after the execution.
  --recompile          Force compilation of files given on command line.
  --quiet              Disables the printing definition data.
  --config             Prints local configuration.
  --lazy               Use lazy evaluation (default).
  --no-lazy            Do not use lazy evaluation.
  --auto               Set the default level for automatic theorem proving.
                       Two naturals: maximum number of nested case analysis
                       and number of let statement for totality.
  --keep-intermediate  Keep intermediate terms in normalisation in the pool
                       (more complete, yet to prove ? but slower).
  --help               Show this usage message.
  -help                Show this usage message.
  -h                   Show this usage message.
\end{verbatim} 
