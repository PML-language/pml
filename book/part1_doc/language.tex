\chapter{PML language and syntax}

\section{Sorts}\label{lang-sort}

PML language uses \emph{sorts} to classify all the expressions of the
languages (excep sorts) like types, values, ordinals, \dots


\noindent \emph{sort} $::=$

\def\w{9.2cm}
\begin{longtable}{rll}
  & $\iota$ \Mid {\tt <iota>} \Mid {\tt <value>}
  & \parbox[t]{\w}{denote the sort for values i.e. results of computation.} \\

  \Mid
  & $\tau$ \Mid {\tt <tau>} \Mid {\tt <term>}
  & \parbox[t]{\w}{denote the sort for terms i.e. program that evaluates to value.} \\

  \Mid
  & $\sigma$ \Mid {\tt <sigma>} \Mid {\tt <stack>}
  & \parbox[t]{\w}{denote the sort of stacks which is used when programming with classical
  logic.}\\

  \Mid
  & $o$ \Mid {\tt <omicron>} \Mid {\tt <prop>}
  & \parbox[t]{\w}{denote the sort of types for terms or propositions (following the
  Curry-Howard correspondance PML identifies types and proposition).
  The letter $o$ is the unicode character omicron, not a lower case latin letter.} \\

  \Mid
  & $\kappa$ \Mid {\tt <kappa>} \Mid {\tt <ordinal>}
  & \parbox[t]{\w}{denote the sort of ordinals used to index inductive and co-inductive
  types.} \\

  \Mid
  & \emph{sort} $\rightarrow$ \emph{sort}
  & \parbox[t]{\w}{the sort for higher-order function like type with parameters. These
  higher-order function should not be confused with functions as programs
  which are of sort $\iota$ or $\tau$. This symbol is right associative,
  $s_1 \rightarrow  s_2 \rightarrow s_3$ means
  $s_1 \rightarrow (s_2 \rightarrow s_3)$.} \\

  \Mid
  & {\tt (} \emph{sort} {\tt )}
  & \parbox[t]{\w}{parenthesis can be used for grouping.} \\
\end{longtable}

The sort $\iota$ is a subsort of $\tau$. This means that any value can also
be considered as a term.

\section{Expressions}\label{lang-expr}

In this section we describe the BNF of PML's expression written \emph{expr}. We will denote
\begin{itemize}
\item \emph{value} the expression of sort $\iota$,
\item \emph{term} the expression of sort $\tau$,
\item \emph{stack} the expression of sort $\sigma$,
\item \emph{prop} the expression of sort $o$,
\item \emph{ordi} the expression of sort $\kappa$.
\end{itemize}

\subsection{Atoms}

We now give a few atomic tokens used in the grammar below.

\begin{longtable}{rll}
\emph{uid} &$::=$& {\tt [A-Z\_][a-zA-Z0-9\_']+} \Mid {\tt true}
\Mid {\tt false}\\
\emph{lid} &$::=$& {\tt [a-z\_][a-zA-Z0-9\_']+} \\
\emph{id}  &$::=$& \emph{lid} \Mid \emph{lid} : \emph{prop} \\
\emph{int} &$::=$& {\tt [-]?[0-9]+} \\
\emph{infix} &$::=$& \hbox{ must be declared see \ref{lang-top}}.
\end{longtable}

\subsection{Values}

\noindent \emph{value} $::=$

\def\w{9.2cm}
\begin{longtable}{rll}
  & $\lambda \emph{id} \dots \emph{id } . \emph{term}$ & \\
  \Mid & ${\tt fun} \; \emph{id} \dots \emph{id } \{ \emph{term} \}$
    & \parbox[t]{\w}{denotes function with one of more arguments.} \\

  \Mid & $[]$ \Mid $\emph{value} :: \emph{value}$ &\\
  \Mid & $\emph{uid} \mid \emph{uid} [ \emph{value} ]$
  & \parbox[t]{\w}{constructor applied to no argument or one argument. In
    fact, no argument means applied to unit, i.e. $\{\}$. $[]$ is a short
    hand for ${\tt Nil}$ and $t :: u$ means ${\tt Cons}[\{ {\tt hd} = t;
      {\tt tl} = u\}]$.} \\

  \Mid & $\{ \emph{id} = \emph{value} ; \dots \}$
  & \parbox[t]{\w}{construction of a record. As in OCaml, $\emph{id} ;$ as a
    field means $\emph{id} = \emph{id}$.} \\

  \Mid & $( \emph{value}, \dots)$
  & \parbox[t]{\w}{tuple construction. As in standard ML this is equivalent
    to a record with numerical labels $1,2,\dots$.} \\

\end{longtable}


\subsection{Terms}
\noindent \emph{value} $::=$

\def\w{9.2cm}
\begin{longtable}{rll}
  \Mid & $ \emph{term} \; \emph{term} $
  & \parbox[t]{\w}{function application. It is left associative: $t_1 \; t_2
    \; t_3$ means $(t_1 \; t_2) \; t_3)$.}\\

  \Mid & $\emph{value} :: \emph{value}$ \\
  \Mid & $\emph{uid} [ \emph{term} ]$
  & \parbox[t]{\w}{syntactic sugar : $C[t]$ means  $(\lambda x.\emph{uid}[x])
    t$. The same for the syntactic sugar for {\tt Cons} if one of both
    arguments are not values a redex is inserted.} \\

  \Mid & $\{ \emph{id} = \emph{term} ; \dots \}$
  & \parbox[t]{\w}{As above, a redex is added for each field wich is not a
    value in a record construction.} \\

  \Mid & $( \emph{term}, \dots)$
    & \parbox[t]{\w}{As above, a redex is added for each field wich is not a
    value in a tuple construction.} \\

  \Mid & \emph{int} & \parbox[t]{\w}{a syntactic sugar is created to
    represent the given integer using function {\tt zero},  {\tt succ}, {\tt
      dble}, and  {\tt opp}. For instance, {\tt 5} means {\tt succ (dble
      (dble (succ zero)))}.} \\

  \Mid & ${\tt if} \; \emph{term} \; {\tt then} \; \emph{term} \; {\tt else}
  \; \emph{term}$ \\
  \Mid & ${\tt case} \; \{ \emph{pat} \rightarrow \emph{term} \dots \}$ &
    \parbox[t]{\w}{case analysis over sum type. See below for the definition
      of the BNF \emph{pat}. The syntax ${\tt if}\; b \; {\tt then} \; t \;
      {\tt else} \; u$ means ${\tt case}\;\{ {\tt true} \rightarrow t {\tt
        false} \rightarrow u\}$.} \\

  \Mid & U+2702 (scisors)  & \parbox[t]{\w}{used to denote inaccessible part of
    a term, in general an impossible case}\\

  \Mid & ${\tt save} \; \emph{lid} \{ \emph{term} \}$ & \parbox[t]{\w}{save the
    current evaluation context (i.e. the stack) for future use with {\tt
      restore}.} \\

  \Mid & ${\tt restore} \; \emph{lid} \; \emph{term} $ & \parbox[t]{\w}{restore
    a previously store evaluation context and evaluate the given term in
    it. This statement corresponds to the $c$ effect.}\\

  \Mid & ${\tt delim} \; \{ \emph{term} \} $ & \parbox[t]{\w}{If the given term
    does not use the $c$ effect in its type of the type of its free variable,
    then we know the the {\tt restore} statement can not escape the term and
    the $c$ effect can be ignored for that term.} \\

  \Mid & ${\tt print} \; \emph{string}$ & \parbox[t]{\w}{Print the given
    string of the standard output. This expression is annotated with the $p$
    effect.}\\

  \Mid & ${\tt fix} \; \emph{id} \{ \emph{term} \}$ & \parbox[t]{\w}{
      The term ${\tt fix} \; x \{ t \}$ is a fixpoint, meaning that
      it is equivalent to $t[x:={\tt fix} \; x \{ t \}]$. PML must be aible
      to prove the termination of this fixpoint unless the current context is
      annotated with the $l$ effect.} \\

  \Mid & ${\tt let}\; \emph{id} = \emph{term}; \emph{term}$ \\
  \Mid & ${\tt let\;rec}\; \emph{id} = \emph{term}; \emph{term}$ &
    \parbox[t]{\w}{The first for is a syntactic sugar for a redex.
      ${\tt let}\; x : a = u; t$ means $({\tt fun}\; x : a \{ t \}) u$.
      The second form uses a fixpoint in the definition:
      ${\tt let rec}\; x : a = u; t$ means $({\tt fun}\; x : a \{ t \}) ({\tt fix}\; x : a \{u\})$.} \\

    \Mid & $\{- \dots -\}$ & \parbox[t]{\w}{denotes a hole in a term, a term
      yet to be written. It must not contain a newline, but could use any
      charracter.}
\end{longtable}

\subsection{Stacks}

There is no specific syntax for stack except for identifier introduced by the
{\tt save} keyword.

\def\w{9.2cm}
\begin{longtable}{rll}
\end{longtable}

\subsection{Ordinals}

\noindent \emph{ordi} $::=$

\def\w{9.2cm}
\begin{longtable}{rll}
  $\infty$ & \parbox[t]{\w}{denotes an ordinal large enough to imply the
    convergence of all PML $mu$ and $nu$ fixpoint. $\mu x, p$ means $\mu\_\infty x, t$. } \\
  $\emph{ordi} +_o \emph{int}$ & \parbox[t]{\w}{denotes the addition
    of a positive natural to an ordinal.} \\
\end{longtable}

\subsection{Propositions}

\noindent \emph{prop} $::=$

\def\w{9.2cm}
\begin{longtable}{rll}
       & $\emph{prop} \Rightarrow \emph{prop}$ & \\
  \Mid & $\emph{prop} \rightarrow \emph{prop}$ & \\
  \Mid & $\emph{prop} ↝ \emph{prop}$ & \\
  \Mid & $\emph{prop} \rightarrow_{(\emph{effects})} \emph{prop}$ &
  \parbox[t]{\w}{propositional
  implication and function type. The implication is indexed by the possible
  effects of the function. Currently {\tt l} if the function may loop, {\tt
    p} if the function perform some printing on the standard output and {\tt
    c} if the function may restore a previously saved stack. The symbol
  $\Rightarrow$ is a short cut for pure function type
  i.e. $\rightarrow_{()}$. The symbol $\rightarrow$ and $↝$ mean respectively
  $\rightarrow_{(cp)}$ and $\rightarrow_{(cpl)}$. }\\

  \Mid & $\emph{prop} \times \emph{prop} \times \dots$ & product type (i.e. type
  of tuple.). \\

  \Mid & $\{ \emph{lid} : \emph{prop} ; \dots \}$ & \\
  \Mid & $\{ \emph{lid} : \emph{prop} ; \dots ; {\tt ...} \}$ &
  \parbox[t]{\w}{record type, indicating the type of each field. If there is
    three dots before the closing brace, the record type is open, more field
    may be present in an element of this type. I fact, the strict version is
    a syntactic sugar.  $\{ l_1 : A_1; \dots; l_n : A_n \}$ means $\exists
    x_1 \dots x_n:\iota, \{ l_1 = x_1, \dots, l_n = x_n \} : \{ l_1 : A_1;
    \dots; l_n : A_n ; {\tt ...}  \}$.  The final dots may be one unicode
    character or three ascii dots.} \\

  \Mid & $\emptyset$ \Mid $[.]$ & \\
  \Mid & $[ \emph{uid} \; {\tt of} \; \emph{prop} ; \dots ]$ &
  \parbox[t]{\w}{sum type inicating the type of the argument of each
    constructor. The ${\tt of} \emph{prop}$ may be ommited if the type is
    unit, i.e. $\{\}$. $\emptyset$ and $[.]$ both denote the empty sum
    type. $[]$ is the empty list and not a sum type.} \\

  \Mid & $\emph{term} \in \emph{prop}$ &
  \parbox[t]{\w}{denotes the singleton type containing only the given term of
    the given type.} \\

  \Mid & $\emph{prop} | \emph{term} \equiv \emph{term}$ & \\
  \Mid & $\emph{prop} | \emph{term} \downarrow$ & \\
  \Mid & $\emph{term} \equiv \emph{term}$ & \\
  \Mid & $\emph{term}$ &
  \parbox[t]{\w}{corresponds to the restiction type. It is the empty type if
    the condition is false, otherwise it is the given type. The condition
    $t_1 \equiv t_2$ is true when $t_1$ and $t_2$ are equivalent (PML
    equivalence is more of less observational equivalence). $t_1\downarrow$
    is true if $t_1$ evaluates to a value. The two last forms are syntactic
    sugar: $t_1 \equiv t_2$ means $\{\} | t_1 \equiv t_2$ and $t_1$ means
    $\{\} | t_1 \equiv {\tt true}$. The last form allows to use any term of
    boolean type as a proposition. Because of syntactic ambiguïties,
    variables and higher-order applications are forbidden in the last form.} \\

  \Mid & $\emph{term} \equiv \emph{term} ↪ \emph{prop}$ & \\
  \Mid & $\emph{term} \downarrow  ↪ \emph{prop}$ &
  \parbox[t]{\w}{ dentes propositional implication. The type is the top type
    containing all terms if the condition is false. It is the given type
    otherwise. This type differs from restrction only when the condition is false.} \\

  \Mid & $\forall \emph{id} \dots. \emph{prop}$ & \\
  \Mid & $\forall \emph{id} \dots : \emph{sort}. \emph{prop}$ & \\
  \Mid & $\forall \emph{id} \dots \in \emph{prop}. \emph{prop}$ &
  \parbox[t]{\w}{denotes universal quantification. In the first form, the
    sort of the variables is infered by PML while in the second form it is
    explicitely written. The last form is a short cut for dependant type.
    $\forall x_1 \dots x_n \in A.B$ means $\forall x_1 \dots x_n : \iota. x_1
    \in A \Rightarrow \dots \Rightarrow x_n \in A \Rightarrow B$.} \\

  \Mid & $\exists \emph{id} \dots. \emph{prop}$ & \\
  \Mid & $\exists \emph{id} \dots : \emph{sort}. \emph{prop}$ & \\
  \Mid & $\exists \emph{id} \dots \in \emph{prop}. \emph{prop}$ & \\
  \Mid & $\{ \emph{id} \in \emph{prop}\}$ &
  \parbox[t]{\w}{denotes universal quantification. In the first form, the
    sort of the variables is infered by PML while in the second form it is
    explicitely written. The last form is a short cut for dependant product.
    $\exists x_1 \dots x_n \in A.B$ means $\exists x_1 \dots x_n : \iota. x_1
    \in A \times \dots \times x_n \in A \times B$. The last for is also a
    short cut: $\{x \in A\}$ means $\exists x. x \in A$.} \\

  \Mid & $\mu \emph{id}, \emph{prop}$ & \\
  \Mid & $\mu\_\emph{ordi} \; \emph{id}, \emph{prop}$ &
  \parbox[t]{\w}{Least fixpoint of proposition or parametric
    proposition. This means that $\mu x, a$ may be of sort $s_1 \rightarrow
    \dots s_n \rightarrow o$ when both $x$ and $a$ have this sort. The
    form with an ordinal denotes a partial construction of the fixpoint and
    is used to prove termination of programs.} \\

  \Mid & $\nu \emph{id}, \emph{prop}$ & \\
  \Mid & $\nu\_\emph{ordi} \; \emph{id}, \emph{prop}$ &
  \parbox[t]{\w}{Greatest fixpoint of proposition or parametric
    proposition. This means that $\nu x, a$ may be of sort $s_1 \rightarrow
    \dots s_n \rightarrow o$ when both $x$ and $a$ have this sort. The
    form with an ordinal denotes a partial construction of the fixpoint and
    is used to prove productivity of programs.} \\
\end{longtable}

\subsection{General expressions}

\noindent \emph{expr} $::=$

\def\w{9.2cm}
\begin{longtable}{rll}
  & $ \emph{lid} $ & variable. \\

  \Mid & $( \emph{lid} : \emph{sort} \mapsto \emph{expr} )$ &
  \parbox[t]{\w}{corresponds to
  higher-order abstraction. If $e$ is an expression of sort $s_2$ using a
  variable $x$ of sort $s_1$ then $(x : s_1 \mapsto e)$ is of sort $s_1
  \rightarrow s_2$.} \\

  \Mid & $\emph{expr}\langle\emph{expr}, \dots\rangle$ &
  \parbox[t]{\w}{denotes higher-order application. $e_1\langle e_2,
    e_3\rangle$ is a short cut for $e_1\langle e_2\rangle\langle
    e_3\rangle$. $e_1\langle e_2\rangle$ is of sort $s_2$ if $e_1$ is of sort
    $s_1 \rightarrow s_2$ and $e_2$ is of sort $s_1$.}\\

  \Mid & ( \emph{expr} ) & parenthesis for grouping.\\
\end{longtable}

\subsection{proofs}

PML does not have a specific language for proofs. However, we provide a few
syntactic sugar to make proofs more readable for non specialist.

We first give a BNF for a few equivalent keywords. Depending on the proofs,
some keyword may give a more natural proofs than other.

\noindent \emph{show} $::= {\tt show}$ \Mid ${\tt deduce}$ \Mid ${\tt prove}$

\noindent \emph{assume} $::= {\tt assume}$ \Mid ${\tt know}$

\noindent \emph{showing} $::= {\tt from}$ \Mid ${\tt showing}$

\noindent \emph{because} $::= {\tt because}$ \Mid ${\tt using}$ \Mid ${\tt by}$

First, we have the {\tt qed} keyword and
two syntactic sugar to define function application that we use
when the type of the variable are hypothesis of a theorem:

\noindent \emph{value} $::= ...$
\def\w{9.2cm}
\begin{longtable}{rll}
  \Mid & ${\tt qed}$ & a synonymous for the empty record $\{\}$.\\
  \Mid & ${\tt take} \; \emph{id} \dots \emph{id }  \{ \emph{term} \}$ & \\
  \Mid & ${\tt suppose}\; \emph{prop}, \dots ; \emph{term}$ &
   \parbox[t]{\w}{the syntax with the {\tt take} keyword is fully equivalent
     the same with {\tt fun} and is used to prove universal quantifications.
     We use {\tt suppose} when we do not need
   a name for the variables, typically for types which are hypothesis.} \\
\end{longtable}

Then, we have a few extension for expressions

\noindent \emph{expr} $::= ...$
\def\w{9.2cm}
\begin{longtable}{rll}
  \Mid & ${\tt use} \; \emph{term}$ & \parbox[t]{\w}{the statement ${\tt use}\;
    t$ is equivalent to $t$ but may be more natural when $t$ is the
    invocation of some lemma or theorem.}\\
  \Mid & $\emph{show} \; \emph{prop} $ \\
  \Mid & $\emph{show} \; \emph{prop} \;\emph{because} \; \emph{term} $ \\
  \Mid & $\emph{show} \; \emph{term}
         \begin{array}[t]{l}
           \equiv \emph{term} \; \emph{because} \; \emph{term} \\
           \equiv \emph{term} \; \emph{because} \; \emph{term} \\
           \dots
         \end{array}$ &
         \parbox[t]{\w}{The first form ${\tt show}\; p; t$ is equivalent to
           $({\tt qed} : p)$. The second ${\tt show}\; p \; {\tt because}
           \; u$ means $(u : p)$. The term
           following the keyword {\tt because} must be of priority prefix or
           between curly braces. The last form is equivalence to a sequence
           of {\tt show}, the justification of each line being optional. For
           instance $\begin{array}[t]{ll}{\tt show}\; a &\equiv b \;
             {\tt using} \; l \\&\equiv c \end{array}$ means $(l :
           a \equiv b); ({\tt qed} : b \equiv c)$.}\\

  \Mid & $\emph{showing} \; \emph{prop} ; \emph{term}$  & \parbox[t]{\w}{is
    used for backward reasonning to mean that the current goal is implied by
    the given proposition. This can not be the last statement of a proof
    hence the term at the end. ${\tt showing}\; p; t$ means
     ${\tt let}\; \_ : a = t; p$.}\\

  \Mid & $\emph{assume} \; \emph{term}; \; \emph{term}$  \\
  \Mid & $\emph{assume} \; \emph{term} \; \emph{because} \; \emph{term}; \; \emph{term}$  &
   \parbox[t]{\w}{${\tt assume}\; t; p$ perfoms
    a case analysis on $t$ to prove that $t$ is equal to {\tt true}. It is
    expended to ${\tt case}\; t \{ {\tt false} \rightarrow
    {\tt qed} \;  {\tt true} \rightarrow p  \}$. ${\tt know}\; t {\tt by}
    q; p$ means ${\tt case}\; t \{ {\tt false} \rightarrow
    q \;  {\tt true} \rightarrow p  \}$. Again, this can not be the last
    statement of a proof hence the final term.} \\

\end{longtable}

\section{Top level statements}\label{lang-top}
