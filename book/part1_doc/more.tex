\chapter{Subtyping, polymorphic variants, ...}

\section{Append lists}

As first example using subtyping, we will consider the type of lists
extended with a append constructor, this type is a kind of mixture of
lists and binary trees. More importantly, any list will be an append list.

\begin{pmlcode}
  include lib.nat
  include lib.list

  type rec alist⟨a⟩ = [Nil
                      ; Cons of {hd : a ; tl : alist⟨a⟩}
                      ; Append of {l : alist⟨a⟩; r : alist⟨a⟩}]

  assert list⟨nat⟩ ⊂ alist⟨nat⟩
  assert ¬ alist⟨nat⟩ ⊂ list⟨nat⟩
\end{pmlcode}

We see that the type \dupml{alist} is identical to \dupml{list} except
for an extra constructor \dupml{Append}. This implies that a \dupml{list}
is also an \dupml{alist} while the converse is false. We say that the type
\dupml{list} is a \emph{subtype} of \dupml{alist}. The converse is naturally
false and this can be checked using the \dupml{assert} keyword.

Here is a function converting an append list to a list.

\begin{pmlcode}
  val rec alist_to_list : ∀a, alist⟨a⟩ ⇒ list⟨a⟩ =
  fun l {
    case l {
      []             → []
      h::l           → h::alist_to_list l
      Append[{l; r}] → alist_to_list l @ alist_to_list r
    }
  }
\end{pmlcode}

\begin{exercise}\label{exo-alist-1}
  Define a \dupml{alist_map} function for \dupml{alist} and show that
  mapping and converting to list or converting to list and then mapping yield
  the same result.
\end{exercise}

\section{Integer}

The fact we can use the same variants constructors for to distinct types is
named \emph{polymorphic} variants. Another example of such polymorphic
variant is for unary integer:

\begin{pmlcode}
  // Normalized integers
  type rec pos = [Zero; S of pos]
  type rec neg = [Zero; P of neg]
  type int = [Zero; S of pos; P of neg]

  // Non normalised
  type rec nint = [Zero; S of nint; P of nint]

  assert nat ⊂ int
  assert int ⊂ nint
\end{pmlcode}

The way we define the type \dupml{int} forbids integer like
\dupml{S[P[Zero]]} yielding a unique representation of each integer (its
normal represetation). We also provide a type allowing non normal
representation and we check the expected subtyping relatin using \dupml{assert}.

Then, we can write the succesor and predecessor functions:

\begin{pmlcode}
  val suc : int ⇒ int = fun n {
    case n {
      Zero → S[Zero]
      S[n] → S[S[n]]
      P[n] → n
    }
  }

  val pre : int ⇒ int = fun n {
    case n {
      Zero → P[Zero]
      P[n] → P[P[n]]
      S[n] → n
    }
  }
\end{pmlcode}

\begin{pmlcode}
val suc : int ⇒ int = fun n {
  case n {
    0    → S[0]
    S[p] → S[check S[p] for n]
    P[s] → s
  }
}

val pre : int ⇒ int = fun n {
  case n {
    0    → P[0]
    P[s] → P[check P[s] for n]
    S[p] → p
  }
}
\end{pmlcode}

\begin{pmlcode}
val rec opp : int ⇒ int = fun n {
  case n {
    0    → 0
    S[p] → pre (opp p)
    P[s] → suc (opp s)
  }
}
\end{pmlcode}

\begin{pmlcode}
val rec opp_pos : pos ⇒ neg = fun n {
  case n {
    0    → 0
    S[p] → P[opp_pos p]
  }
}

val rec opp_neg : neg ⇒ pos = fun n {
  case n {
  0    → 0
  P[s] → S[opp_neg s]
  }
}

val rec opp : int ⇒ int = fun n {
  case n {
    0    → 0
    S[p] → P[opp_pos p]
    P[s] → S[opp_neg s]
  }
}
\end{pmlcode}

\begin{pmlcode}
infix (+) = add priority 3 left associative

val rec (+) : int ⇒ int ⇒ int = fun n m {
  case n {
    0    → m
    S[n] → suc (n + m)
    P[n] → pre (n + m)
  }
}

infix (-) = minus priority 3 left associative

val rec (-) : int ⇒ int ⇒ int = fun n m { n + opp m }
\end{pmlcode}

\section{Subtyping for records: binary search trees}

\begin{pmlcode}
type rec st1⟨a⟩ = [ Nil
                 ; Node of { l : st1⟨a⟩ ; e : a ; r : st1⟨a⟩ ; ⋯ } ]

include lib.bool
include lib.comparison

val rec for_all : ∀a, (a ⇒ bool) ⇒ st1⟨a⟩ ⇒ bool = fun f t {
  case t {
    | []               → true
    | Node[{ l; e; r}] → f e && for_all f l && for_all f r
  }
}

type rec st⟨a,cmp⟩ = [ Nil
  ; Node of
  ∃e, { l : { t ∈ st⟨a,cmp⟩ | for_all (λx.is_Ls (cmp x e)) t }
      ; e : e ∈ a
      ; r : { t ∈ st⟨a,cmp⟩ | for_all (λx.is_Gs (cmp x e)) t }
    ; ⋯ } ]

val rec add : ∀a, a ⇒ st1⟨a⟩ ⇒ st1⟨a⟩ = {--}
\end{pmlcode}

%<!-- Local IspellDict: british -->
%<!-- Local IspellPersDict: ~/.ispell-british -->
