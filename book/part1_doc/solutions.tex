
\chapter{Solutions}

\begin{description}
\item[\ref{exo-day-1}]

  \begin{pmlcode}
    include book.part1_doc.basics

    val rec iter : nat ⇒ ∀a, (a ⇒ a) ⇒ a ⇒ a = fun n f a {
      case n {
        0 → a
        S[n] → iter n f (f a)
      }
    }

    val next_day_seven : ∀d∈day, iter 7 next_day d ≡ d =
      take d;
      case d {
        Monday    → qed
        Tuesday   → qed
        Wednesday → qed
        Thursday  → qed
        Friday    → qed
        Saturday  → qed
        Sunday    → qed
      }
  \end{pmlcode}

\item[\ref{exo-bool-1}]

  \begin{pmlcode}
    infix (=>) = imply⟨⟩ priority 8 right associative

    def (=>)⟨b1:τ,b2:τ⟩ = if b1 { b2 } else { true }

    val tauto1 : ∀b1 b2 b3∈bool, (b1 && b2) => b3 ≡ b1 => (b2 => b3) =
      take b1 b2 b3;
      if b1 { if b2 { qed } else { qed }} else { qed }
  \end{pmlcode}

\item[\ref{exo-bool-2}]

  \begin{pmlcode}
    infix (^^) = xor priority 7 right associative

    val xor : bool ⇒ bool ⇒ bool = fun b1 b2 {
      if b1 { not b2 } else { b2 }
    }

    set auto 3 3

    val xor_com : ∀b1 b2∈bool, b1 ^^ b2 ≡ b2 ^^ b1 =
      take b1 b2; qed

    val xor_ass : ∀b1 b2 b3∈bool, b1 ^^ (b2 ^^ b3) ≡ (b1 ^^ b2) ^^ b3 =
      take b1 b2 b3; qed

    val xor_neutral : ∀b1∈bool, b1 ^^ false ≡ b1 =
      take b1; qed

    val xor_opp : ∀b1∈bool, b1 ^^ b1 ≡ false =
      take b1; qed

    val and_com : ∀b1 b2∈bool, b1 && b2 ≡ b2 && b1 =
      take b1 b2; qed

    val and_ass : ∀b1 b2 b3∈bool, b1 && (b2 && b3) ≡ (b1 && b2) && b3 =
      take b1 b2 b3; qed

    val and_abs :  ∀b1∈bool, b1 && false ≡ false =
      take b1; qed

    val and_neutral : ∀b1∈bool, b1 && true ≡ b1 =
      take b1; qed

    val xor_dist_and :
        ∀b1 b2 b3∈bool, b1 && (b2 ^^ b3) ≡ (b1 && b2) ^^ (b1 && b3) =
      take b1 b2 b3; qed
  \end{pmlcode}

\item[\ref{exo-nat-1}] See {\tt lib/nat\_proofs.pml}

\item[\ref{exo-nat-2}]

  \begin{pmlcode}
    include lib.nat
    include lib.nat_proofs

    val rec pow : nat ⇒ nat ⇒ nat = fun n e {
      case e {
        0    → 1
        S[e] → n * pow n e
      }
    }

    val rec pow_add
        : ∀n e1 e2∈nat, pow n (e1 + e2) ≡ pow n e1 * pow n e2 =
      take n e1 e2;
      case e1 {
        0    → show pow n e1 * pow n e2 ≡ 1 * pow n e2
                 ≡ pow n e2 by mul_one_n (pow n e2)
        S[e] → show pow n (e1 + e2) ≡ n * pow n (e + e2)
                 ≡ n * (pow n e * pow n e2) by pow_add n e e2
                 ≡ (n * pow n e) * pow n e2
                   by mul_assoc n (pow n e) (pow n e2)
                 ≡ pow n e1 * pow n e2
      }

    val rec pow_one_n : ∀n∈nat, pow 1 n ≡ 1 =
      take n;
      case n {
        0    → qed
        S[m] → show 1 * pow 1 m ≡ pow 1 m by mul_one_n (pow 1 m)
                                ≡ 1 by pow_one_n m
      }

    val rec pow_mul_rev
        : ∀n e1 e2∈nat, pow n (e1 * e2) ≡ pow (pow n e2) e1 =
      take n e1 e2;
      case e1 {
        0    → qed
        S[e] → show pow n (e2 + e * e2) ≡ pow n e2 * pow n (e * e2)
                 by pow_add n e2 (e * e2)
               ≡ pow n e2 * pow (pow n e2) e by pow_mul_rev n e e2
               ≡ pow (pow n e2) e1
        }

    val rec pow_mul
        : ∀n e1 e2∈nat, pow n (e1 * e2) ≡ pow (pow n e1) e2 =
      take n e1 e2;
      use mul_comm e1 e2;
      use pow_mul_rev n e2 e1;
      qed
  \end{pmlcode}
\end{description}
%<!-- Local IspellDict: british -->
%<!-- Local IspellPersDict: ~/.ispell-british -->
